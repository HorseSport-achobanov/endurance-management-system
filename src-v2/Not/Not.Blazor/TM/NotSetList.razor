@using Not.Blazor.Components
@using Not.Blazor.Forms
@using Not.Blazor.Mud.Components
@using Not.Blazor.Navigation
@using Not.Blazor.TM.Forms
@using Not.Blazor.TM.Forms.Components
@using Not.Exceptions
@using Not.Services

@inherits NotComponent
@typeparam T
@typeparam TForm where TForm : NotForm<T>

<MudPaper Elevation="0" Class="@("pa-4 " + Class)" Style="@Style">

    <MudStack Row="true" Class="mb-2">
        <NotH2 Class="pt-1">@Name</NotH2>

        <MudSpacer />

        <NotButtonCreate Variant="Variant.Outlined" OnClick="CreateHandler" />
    </MudStack>

    @if (Items == null || !Items.Any())
    {
        <MudText Typo="Typo.body1">@EmptyMessage</MudText>
    }
    else
    {
        @foreach (var item in Items)    
        {
            <MudStack Row="true">
                <MudText Typo="Typo.body1" Class="pa-4">@item</MudText>

                <MudSpacer />

                <NotIconButtonUpdate OnClick="() => this._formNavigator.Update(UpdateRoute, item)" />

                <NotIconButtonDelete OnClick="() => DeleteHandler(item)" />
            </MudStack>

            <MudDivider />
        }        
    }
</MudPaper>

@code {
    [Inject]
    private INotSetBehind<T> _behind { get; set; } = default!;
    [Inject]
    private IFormNavigator<T, TForm> _formNavigator { get; set; } = default!;

    [Parameter]
    public string? Name { get; set; }
    [Parameter]
    public string UpdateRoute { get; set; } = default!;

    public string EmptyMessage { get; set; } = default!;
    public IEnumerable<T> Items { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        GuardHelper.ThrowIfDefault(UpdateRoute);

        Name = Localizer.Get(Name ?? GetDefaultName());
        //TODO improve the default message to enable a single translation entry for all empty component messagesz
        if(EmptyMessage == default)
        {
            string defaultMessage = $"No {Name.ToLower()} have been created for this event.";
            EmptyMessage = Localizer.Get(defaultMessage);
        }
        Items = await _behind.GetAll();
    }

    // TODO: Implement ObservableBehind pattern
    public async Task CreateHandler()
    {
        await _formNavigator.Create();
        Items = await _behind.GetAll();
        await InvokeAsync(StateHasChanged);
    }

    public async Task DeleteHandler(T item)
    {
        await _behind.Delete(item);
        Items = await _behind.GetAll();
        await InvokeAsync(StateHasChanged);
    }

    string GetDefaultName()
    {
        return $"{typeof(T).Name}s";
    }
}